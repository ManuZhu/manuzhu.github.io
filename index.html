<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Manu Zhu">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Manu Zhu">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Manu Zhu">
<meta property="article:tag" content="web security, misc, crypto, hustlab">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Manu Zhu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Manu Zhu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">穷者独善其身</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/13/Web%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Manu Zhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Manu Zhu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/Web%20Notes/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-13 18:00:35 / Modified: 18:25:43" itemprop="dateCreated datePublished" datetime="2021-01-13T18:00:35+08:00">2021-01-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CTF-WEB"><a href="#CTF-WEB" class="headerlink" title="CTF WEB"></a>CTF WEB</h2><h3 id="PHP相关"><a href="#PHP相关" class="headerlink" title="PHP相关"></a>PHP相关</h3><ul>
<li><p>利用<strong>scapeshellcmd</strong>逃脱<strong>escapeshellarg</strong>单引号的束缚</p>
<p>传入的参数是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.17.0.2&#39; shellcode&#39;</span><br></pre></td></tr></table></figure>

<p>经过escapeshellarg处理后变成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;172.17.0.2&#39;\&#39;&#39; shellcode&#39;\&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</p>
<p>经过escapeshellcmd处理后变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;172.17.0.2&#39;\\&#39;&#39; shellcode&#39;\\&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>这是因为escapeshellcmd对\以及最后那个不配对的引号进行了转义：</p>
<p>最后执行的命令是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#39;172.17.0.2&#39;\\&#39;&#39; shellcode&#39;\\&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>由于中间的\被解释为\而不再是转义字符，所以后面的’没有被转义，与再后面的’配对成了一个空白连接符</p>
<p>所以可以简化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 172.17.0.2\ shellcode&#39;\&#39;</span><br></pre></td></tr></table></figure>

<p>即向172.17.0.2\发起请求，并执行shellcode。</p>
</li>
<li><p>php 单引号只会解析转义字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\、\’</span><br></pre></td></tr></table></figure>

<p>双引号则会解析变量的值，同时解析所有转义字符</p>
</li>
</ul>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><ul>
<li>在$v可控的情况下，可以传入元素为一个对象和函数名的数组，这样$v()就能调用这个对象的方法</li>
<li>php反序列化逃逸参考这个<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6718">https://xz.aliyun.com/t/6718</a></li>
</ul>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><ul>
<li><p>低版本ngnix .htaccess 解析漏洞的利用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application&#x2F;x-httpd-php .png</span><br></pre></td></tr></table></figure>

<p>可以将png文件解析为php</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;1&quot;&gt;SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  把文件名包含1的解析为php</p>
<ul>
<li><p>php还可以写作php3,php5,phtml</p>
</li>
<li><p>对&lt;?的过滤可以用下面这个语句绕过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;php&gt;system(&quot;cat &#x2F;flag&quot;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CGI／FastCGI 模式的服务器上.user.ini的利用</p>
<p>auto_prepend_file和auto_append_file我们指定一个文件（如a.jpg），</p>
<p>那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(.&#x2F;a.jpg);</span><br></pre></td></tr></table></figure>

<p>这两个设置的区别只是在于auto_prepend_file是在文件前插入</p>
<p>auto_append_file在文件最后插入（当文件调用的有exit()时该设置无效）</p>
</li>
<li><p>双文件上传绕过同时上传两个文件</p>
<p>第一个文件为合法文件，第二个为马。php判断第一个文件合法即令 EnableUplad 的值为 True，是第二个文件成功绕过。</p>
</li>
</ul>
<h3 id="文件包含-读取"><a href="#文件包含-读取" class="headerlink" title="文件包含/读取"></a>文件包含/读取</h3><ul>
<li><p>file_get_contents:<br>$str = $_GET[‘cmd’];$a = file_get_contents($str,’r’);if($a === “XXXX”)<br>这时需要给cmd赋为php://input，这样就会读取post中的内容，但post格式不能为 multipart/form-data。<br>目录穿越时是不能出现文件的，只能是目录。</p>
</li>
<li><p>include：<br>读取文件时可以利用<br>file=php://filter/read=convert.base64-encode/resource=flag.phpfile=php://filter/convert.base64-encode/resource=index.php<br>读取文件内容。</p>
</li>
<li><p>LFI（local file inclusion vulnerability） To RCE：参考[这个](<a target="_blank" rel="noopener" href="https://bbs.zkaq.cn/t/3639.html[https://www.k0rz3n.com/2018/11/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8B%20PHP%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/#5-proc-self-environ]">https://bbs.zkaq.cn/t/3639.html[https://www.k0rz3n.com/2018/11/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8B%20PHP%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/#5-proc-self-environ]</a>(<a target="_blank" rel="noopener" href="https://www.k0rz3n.com/2018/11/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8B">https://www.k0rz3n.com/2018/11/20/一篇文章带你理解漏洞之</a> PHP 文件包含漏洞/#5-proc-self-environ))</p>
</li>
<li><p>phar:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	@unlink(&quot;phar.phar&quot;);</span><br><span class="line">	$phar &#x3D; new Phar(&quot;phar.phar&quot;);</span><br><span class="line">	$phar-&gt;startBuffering();</span><br><span class="line">	$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);&#x2F;&#x2F;设置stub</span><br><span class="line">	$phar-&gt;addFromString(&quot;head.txt&quot;, &quot;&lt;?php phpinfo();?&gt;&quot;); &#x2F;&#x2F;添加要压缩的文件及内容</span><br><span class="line">	&#x2F;&#x2F;签名自动计算</span><br><span class="line">	$phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>data:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data:,&lt;文本数据&gt;</span><br><span class="line">data:text&#x2F;plain,&lt;文本数据&gt;</span><br><span class="line">data:text&#x2F;html,&lt;HTML代码&gt;</span><br><span class="line">data:text&#x2F;html;base64,&lt;base64编码的HTML代码&gt;</span><br><span class="line">data:text&#x2F;css,&lt;CSS代码&gt;</span><br><span class="line">data:text&#x2F;css;base64,&lt;base64编码的CSS代码&gt;</span><br><span class="line">data:text&#x2F;javascript,&lt;Javascript代码&gt;</span><br><span class="line">data:text&#x2F;javascript;base64,&lt;base64编码的Javascript代码&gt;</span><br><span class="line">data:image&#x2F;gif;base64,base64编码的gif图片数据</span><br><span class="line">data:image&#x2F;png;base64,base64编码的png图片数据</span><br><span class="line">data:image&#x2F;jpeg;base64,base64编码的jpeg图片数据</span><br><span class="line">data:image&#x2F;x-icon;base64,base64编码的icon图片数据</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>包含session</p>
<p>session默认存放位置</p>
<ul>
<li>/var/lib/php/sess_PHPSESSID</li>
<li>/var/lib/php/sessions/sess_PHPSESSID</li>
<li>/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID</li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/13/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Manu Zhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Manu Zhu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-13 17:44:49" itemprop="dateCreated datePublished" datetime="2021-01-13T17:44:49+08:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-08 11:56:39" itemprop="dateModified" datetime="2021-01-08T11:56:39+08:00">2021-01-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>第一代计算机网络——电路交换网络</p>
<p>第二代计算机网络——分组交换网络</p>
<p>分组交换 VS 电路交换</p>
<ul>
<li>若要连续传送大量数据，且其传送时间远大于呼叫建<br>立时间，则采用在数据通信之前预先分配传输带宽的<br>电路交换较为合适</li>
<li>分组交换不需要预先分配传输带宽，在传送突发数据<br>时可提高整个网络的信道利用率  </li>
</ul>
<h4 id="分组交换网络的时延类型"><a href="#分组交换网络的时延类型" class="headerlink" title="分组交换网络的时延类型"></a>分组交换网络的时延类型</h4><ul>
<li>传输时延：将分组比特流发送到链路上的时间</li>
</ul>
<ul>
<li>传播时延：分组比特流在链路上的传播时间</li>
<li>排队时延：当分组传入某个端时，发现该端输出队列还有其他分组，该分组需要排队，队列为空时，排队时延为<strong>0</strong>，队列已满时，分组被<strong>丢弃</strong></li>
<li>处理时延：路由器决定分组最终去向的时间和刚刚传入时的检查差错时间</li>
</ul>
<h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><ul>
<li>实体(Entity)<ul>
<li>实体是任何可以发送和接收信息的硬件和软件进程。通常是一个特定的软件模块</li>
</ul>
</li>
<li>对等体(Peer)<ul>
<li>不同机器上包含对应层的实体称为对等体</li>
</ul>
</li>
<li>协议(Protocol)<ul>
<li>语法，即数据与控制信息的结构或格式</li>
<li>语义，即需发现何种控制信息，完成何种动作以及做出何种应答</li>
<li>同步，即事件实现顺序的详细说明  </li>
</ul>
</li>
<li>服务(Service)<ul>
<li>为保证上层对等体之间能互相通信，下层向上层提供的功能。</li>
</ul>
</li>
<li>服务原语<ul>
<li>服务原语是指网络相邻层间进行交互时所要交换的一些必要命令</li>
</ul>
</li>
<li>服务访问点(SAP)<ul>
<li>服务访问点是同一系统中相邻两层的实体进行交互的地方</li>
</ul>
</li>
<li>协议数据单元(PDU)：协议数据单元是对等层次上传送数据的单位<ul>
<li>应用层的PDU称为<strong>数据</strong></li>
<li>传输层的PDU称为<strong>数据段</strong></li>
<li>网络层的PDU称为<strong>数据包</strong></li>
<li>网络接口层得PDU称为<strong>帧</strong></li>
<li>介质实际传输实际使用的PDU称为<strong>比特（位）</strong></li>
</ul>
</li>
<li>服务数据单元(SDU)<ul>
<li>服务数据单元是层与层之间交换数据的单位</li>
</ul>
</li>
<li>网络体系结构(Network Architecture)<ul>
<li>网络体系结构就是层和协议的集合</li>
</ul>
</li>
<li>协议栈(Protocol Stack)<ul>
<li>一个特定的系统所使用的一组协议（每层一个协议）称为协议栈</li>
</ul>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>C/S，P2P，混合体系结构</p>
<h3 id="服务需求"><a href="#服务需求" class="headerlink" title="服务需求"></a>服务需求</h3><p>可靠传输，带宽自动控制，实时性，安全性</p>
<h3 id="常见应用采用的传输协议"><a href="#常见应用采用的传输协议" class="headerlink" title="常见应用采用的传输协议"></a>常见应用采用的传输协议</h3><table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">应用协议</th>
<th align="center">所依赖的传输协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">e-mail</td>
<td align="center">smtp</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">远程中断访问</td>
<td align="center">telnet</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">Web</td>
<td align="center">http</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">文件传输</td>
<td align="center">ftp</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">流媒体</td>
<td align="center">专有协议</td>
<td align="center">TCP or UDP</td>
</tr>
<tr>
<td align="center">远程文件服务器</td>
<td align="center">NFS</td>
<td align="center">TCP or UDP</td>
</tr>
<tr>
<td align="center">IP电话</td>
<td align="center">专有协议</td>
<td align="center">typically UDP</td>
</tr>
</tbody></table>
<p>TCP和UDP不具备安全性，需要通过其他协议保证传输数据的安全性（如SSL）</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>标识每一个网络应用进程，独一无二</p>
<p>主机地址（32位）+端口地址（16位）</p>
<h3 id="网络应用（1）——WEB（C-S模式）"><a href="#网络应用（1）——WEB（C-S模式）" class="headerlink" title="网络应用（1）——WEB（C/S模式）"></a>网络应用（1）——WEB（C/S模式）</h3><h4 id="web的构成"><a href="#web的构成" class="headerlink" title="web的构成"></a>web的构成</h4><ul>
<li>web服务器</li>
<li>浏览器</li>
<li>协议：信息表达协议——HTML，信息传输协议——HTTP</li>
</ul>
<h4 id="web内容的表达——HTML"><a href="#web内容的表达——HTML" class="headerlink" title="web内容的表达——HTML"></a>web内容的表达——HTML</h4><p>web页面由一些对象组成，任何一个对象都可以用<strong>URL</strong>来定位</p>
<h4 id="web内容的传输——HTTP协议"><a href="#web内容的传输——HTTP协议" class="headerlink" title="web内容的传输——HTTP协议"></a>web内容的传输——HTTP协议</h4><p>http协议：TCP传输服务，80端口，http报文在浏览器和服务器之间交换</p>
<p>http1.0——非持久性连接，每次操作消耗文件传输时间和两个往返时延<strong>RTT</strong>，操作结束关闭连接</p>
<p>http1.1——持久连接，直至连接休息了一段较长时间后断开连接，减少了服务器端连接数。</p>
<p>持久连接可分为<strong>流水线方式</strong>（一次性发送所有请求），<strong>非流水线方式</strong>（一个对象传输完成方能传输下一个）</p>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><ul>
<li>请求行=请求方法+URL+版本</li>
<li>首部行=（若干）首部字段名+值</li>
<li>空行</li>
<li>实体主体（Body）</li>
</ul>
<h5 id="支持的请求方法"><a href="#支持的请求方法" class="headerlink" title="支持的请求方法"></a>支持的请求方法</h5><ul>
<li>http1.0：GET，POST，HEAD（请求服务器返回一个响应报文，常用来追踪故障）</li>
<li>http1.1新增：PUT（上传文件，文件放主体中，上传路径放URL字段），DELETE（删除URL字段中指定的文件）</li>
</ul>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><ul>
<li>状态行=版本+状态编码+短语</li>
<li>首部行=（若干）首部字段名+值</li>
<li>空行</li>
<li>实体主体</li>
</ul>
<h5 id="常见相应状态码和短语"><a href="#常见相应状态码和短语" class="headerlink" title="常见相应状态码和短语"></a>常见相应状态码和短语</h5><ul>
<li>200 OK：请求成功, 被请求的对象在报文中  </li>
<li>301 Moved Permanently：被请求的对象被移动过, 新的位置在报文中有说明(Location:)</li>
<li>400 Bad Request：服务器不懂请求报文</li>
<li>404 Not Found：服务器上找不到请求的对象</li>
<li>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本</li>
</ul>
<h5 id="用户-服务器交互——Cookie"><a href="#用户-服务器交互——Cookie" class="headerlink" title="用户-服务器交互——Cookie"></a>用户-服务器交互——Cookie</h5><p>使用目的：限制用户的访问，把内容和用户身份关联起来。</p>
<p>保存用户的端系统，由用户浏览器负责管理。</p>
<h3 id="网络应用（2）——电子邮件"><a href="#网络应用（2）——电子邮件" class="headerlink" title="网络应用（2）——电子邮件"></a>网络应用（2）——电子邮件</h3><h4 id="电子邮件系统的构成"><a href="#电子邮件系统的构成" class="headerlink" title="电子邮件系统的构成"></a>电子邮件系统的构成</h4><ul>
<li>用户代理：写作，编辑，阅读邮件报文</li>
<li>邮件服务器：邮箱，报文队列包含了外发的邮件报文</li>
<li>邮件传输协议（SMTP）：在邮件服务器之间发送邮件</li>
</ul>
<h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><ul>
<li>使用TCP，端口25</li>
<li>传输的三个阶段：握手，报文传输，结束</li>
<li>命令/响应交互</li>
<li>全部报文必须使用7-bit ASCII表示</li>
<li>持续连接</li>
<li>HTTP：每个对象分别装在各自的相应报文中，SMTP：多个对象在一个多分部的报文中传送。</li>
</ul>
<h4 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h4><ul>
<li>header = to + from + subject</li>
<li>body</li>
</ul>
<h4 id="非ASCII码数据的MIME扩展"><a href="#非ASCII码数据的MIME扩展" class="headerlink" title="非ASCII码数据的MIME扩展"></a>非ASCII码数据的MIME扩展</h4><ul>
<li>MIME-Version</li>
<li>Content-Transfer-Encoding</li>
<li>Content-Type</li>
<li>Data</li>
</ul>
<h4 id="客户机获取邮件的方法"><a href="#客户机获取邮件的方法" class="headerlink" title="客户机获取邮件的方法"></a>客户机获取邮件的方法</h4><ul>
<li><p>POP3协议</p>
<ul>
<li>进入客户端，输入user和pass</li>
<li>list：列出报文号码</li>
<li>retr：用报文号码取信</li>
<li>dele：用报文号码删信</li>
<li>quit</li>
</ul>
</li>
<li><p>IMAP协议</p>
</li>
<li><p>HTTP</p>
</li>
</ul>
<p>POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。</p>
<p>而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</p>
<h3 id="网络应用（3）——DNS"><a href="#网络应用（3）——DNS" class="headerlink" title="网络应用（3）——DNS"></a>网络应用（3）——DNS</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>IP地址和域名之间的转换</p>
<h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><ul>
<li>应用层协议</li>
<li>UDP协议，53号端口</li>
<li>C/S模式</li>
</ul>
<h4 id="四类DNS服务器"><a href="#四类DNS服务器" class="headerlink" title="四类DNS服务器"></a>四类DNS服务器</h4><ul>
<li>根DNS服务器：全球一共 13 台，负责返回顶级域 (.com 等) 服务器地址 </li>
<li>顶级域服务器（TLD服务器）： 负责返回一级域 (比如 example.com) 的权威域名服务器地址   </li>
<li>权威DNS服务器：负责返回其域名下的 Address 记录 (A record) </li>
<li>本地域名服务器</li>
</ul>
<h4 id="三种查询方式"><a href="#三种查询方式" class="headerlink" title="三种查询方式"></a>三种查询方式</h4><ul>
<li>递归查询：客户端请求DNS服务器</li>
<li>迭代查询：DNS服务器之间</li>
<li>非递归查询：DNS服务器有缓存，直接返回</li>
</ul>
<h4 id="DNS可提供的服务"><a href="#DNS可提供的服务" class="headerlink" title="DNS可提供的服务"></a>DNS可提供的服务</h4><ul>
<li>域名到ip地址的转换</li>
<li>主机/邮件服务器别名</li>
<li>负载均衡</li>
</ul>
<h4 id="DNS记录格式"><a href="#DNS记录格式" class="headerlink" title="DNS记录格式"></a>DNS记录格式</h4><ul>
<li>type=A,name=hostname,value=ip address</li>
<li>type=CNAME,name=alias,value=real name</li>
<li>type=NS,name=域 (如foo.com) ,value=该域权威域名服务器的主机名</li>
<li>type=MX,value=与name相关的邮件服务器域名  </li>
</ul>
<h3 id="网络应用（4）——P2P文件共享"><a href="#网络应用（4）——P2P文件共享" class="headerlink" title="网络应用（4）——P2P文件共享"></a>网络应用（4）——P2P文件共享</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>所有的计算机都是服务器</p>
<h4 id="文件分发"><a href="#文件分发" class="headerlink" title="文件分发"></a>文件分发</h4><ul>
<li><p>C/S模式<br>$$<br>T_{cs}\geq max{\frac{NF}{u_s}, \frac{F}{min{d_1,d_2,…,d_N}}}<br>$$</p>
</li>
<li><p>P2P模式<br>$$<br>T_{P2P}\geq max{\frac{F}{u_s}, \frac{F}{d_min}, \frac{NF}{u_s+\sum^{i\to N}{d_i}}}<br>$$</p>
</li>
</ul>
<h4 id="BitTorrent基本概念"><a href="#BitTorrent基本概念" class="headerlink" title="BitTorrent基本概念"></a>BitTorrent基本概念</h4><ul>
<li>洪流（torrent）：参与一个特定文件分发的所有对等方的集合  </li>
<li>追踪器（tracker）：跟踪正参与在洪流中的对等方  </li>
<li>文件快（chunk）：256KB</li>
</ul>
<h4 id="BitTorrent工作机制"><a href="#BitTorrent工作机制" class="headerlink" title="BitTorrent工作机制"></a>BitTorrent工作机制</h4><ul>
<li>像另据请求哪些块——最稀罕优先</li>
<li>优先响应哪些请求——对换算法（4+1）<ul>
<li>每10秒重新确定4个最高速率对等方</li>
<li>每30秒随机选一个新的邻居</li>
</ul>
</li>
</ul>
<h3 id="网络应用（5）——视频流"><a href="#网络应用（5）——视频流" class="headerlink" title="网络应用（5）——视频流"></a>网络应用（5）——视频流</h3><p><strong>互联网宽带的主要消费者</strong></p>
<p><strong>分布式应用程序级基础架构</strong></p>
<h4 id="视频编码方式"><a href="#视频编码方式" class="headerlink" title="视频编码方式"></a>视频编码方式</h4><ul>
<li>CBR（恒定Constant比特率）</li>
<li>VBR（可变Variable比特率）</li>
</ul>
<h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h4 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h4><ul>
<li>多路复用，多路分解</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>差错检查</li>
</ul>
<h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h4><ul>
<li>UDP：无连接的运输服务</li>
<li>TCP：面向连接的运输服务、拥塞控制</li>
</ul>
<h4 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h4><p>为不同主机上运行的应用进程之间提供<strong>逻辑通信</strong>  </p>
<h4 id="传输层协议的工作内容"><a href="#传输层协议的工作内容" class="headerlink" title="传输层协议的工作内容"></a>传输层协议的工作内容</h4><ul>
<li>发送方：把<strong>应用数据</strong>划分成<strong>报文段</strong>(segments),交给网络层</li>
<li>接收方：把报文段重组成应用数据，交付给应用层  </li>
</ul>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>标志应用层的进程</p>
<h3 id="传输层协议（1）——UDP"><a href="#传输层协议（1）——UDP" class="headerlink" title="传输层协议（1）——UDP"></a>传输层协议（1）——UDP</h3><p>提供运输层协议必须的服务：多路复用/分解、差错检查</p>
<h4 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h4><p> <img src="http://c.biancheng.net/uploads/allimg/191111/6-1911111249535K.gif" alt="img"> </p>
<h4 id="UDP处理数据的流程"><a href="#UDP处理数据的流程" class="headerlink" title="UDP处理数据的流程"></a>UDP处理数据的流程</h4><p>发送方</p>
<ul>
<li>从应用进程得到数据</li>
<li><strong>附加上</strong>为多路复用/多路分解所需的<strong>源和目的端口号</strong> <strong>（UDP的8字节首部）</strong>及差错检测信息，形成报文段（数据报）</li>
<li>递交给网络层，尽力而为的交付给接收主机  </li>
</ul>
<p>接收方</p>
<ul>
<li>从网络层接收报文段（数据报）</li>
<li>根据目的端口号，将数据交付给相应的应用进程  </li>
</ul>
<h4 id="采用UDP协议的应用"><a href="#采用UDP协议的应用" class="headerlink" title="采用UDP协议的应用"></a>采用UDP协议的应用</h4><ul>
<li>远程文件服务器（NFS）</li>
<li>流式多媒体</li>
<li>因特网电话</li>
<li>网络管理（SNMP）</li>
<li>选路协议（RIP）</li>
<li>域名解析（DNS）  </li>
</ul>
<h4 id="UDP的检验和"><a href="#UDP的检验和" class="headerlink" title="UDP的检验和"></a>UDP的检验和</h4><p>按16bit求和取反，接收方计算和与发送方的检验和相加结果不为全1则检测出错误。</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><h4 id="可靠数据传输协议-rdt"><a href="#可靠数据传输协议-rdt" class="headerlink" title="可靠数据传输协议(rdt)"></a>可靠数据传输协议(rdt)</h4><ul>
<li>rdt_send(): 由上层（如应用层）调用，将数据发送给接收方的上层  </li>
<li>udt_send(): 由 rdt调用,将分组通过不可靠通道传给接收方  </li>
<li>rdt_rcv(): 当分组到达接收方时调用  </li>
<li>deliver_data(): 由 rdt 调用，将数据交付上层</li>
</ul>
<h4 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h4><p>假设底层信道完全可靠：</p>
<ul>
<li>不会产生比特错误</li>
<li>不会丢失分组  </li>
</ul>
<p>分别为发送方和接收方建立FSM</p>
<ul>
<li>发送方将数据发送给底层信道</li>
<li>接收方从底层信道接收数据  </li>
</ul>
<h4 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h4><p>假设</p>
<ul>
<li>分组比特可能受损</li>
<li>所有传输的分组都将按序被接收，不会丢失  </li>
</ul>
<p>出错的解决</p>
<ul>
<li>如何通知发送方分组是否受损——接收方反馈（ACK和NAK）</li>
<li>在得知分组受损后，发送方如何处理——出错重传  </li>
</ul>
<p>如何实现重传：建立缓冲区</p>
<h4 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h4><p>rdt2.0没有考虑ack和nak分组可能受损</p>
<p>采用停等协议。</p>
<p>发送方只有接收到正确的ack包才会发送下一个数据包，否则会不断重发数据包。</p>
<p>接收方当不断收到来自发送方重发的正确数据包时也会不断像发送方发送ack包（这里认为可能是自己的ack包受损了），当接收到一个新的数据包时才会停止这一过程，为了区别新旧数据包，用0和1标记他们。</p>
<h4 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h4><p>NAK和包错误的动作一样，所以可以只用ACK。</p>
<p>接收方对最后一个正确收到的分组发送ACK。</p>
<p>发送方对不是当前包的ACK视作错误，重传当前数据包。</p>
<p>依然使用停等协议，所以只要用0和1编号。</p>
<h4 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h4><p>假设底层信道不但可能出现比特差错，而且可能会丢包</p>
<p>解决：超时重传</p>
<p>问题：停等协议限制了物理资源的利用率</p>
<h4 id="提高性能：流水线技术"><a href="#提高性能：流水线技术" class="headerlink" title="提高性能：流水线技术"></a>提高性能：流水线技术</h4><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul>
<li>分组首部用k比特字段表示序号</li>
<li><strong>未被传输</strong>和<strong>已被传输</strong>但还未确认的分组的许可序号范围可以看作是一个在序号范围内大小为N的窗口</li>
</ul>
<h5 id="当流水线技术中丢失一个分组后："><a href="#当流水线技术中丢失一个分组后：" class="headerlink" title="当流水线技术中丢失一个分组后："></a>当流水线技术中丢失一个分组后：</h5><ul>
<li>Go-Back-N协议：其后分组全部重传</li>
<li>选择重传SR协议：仅重传该分组</li>
</ul>
<h5 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h5><ul>
<li>ACK(n)：序号n之前包括n在内的所有分组已确认</li>
<li>允许连续发送n个数据包，未被确认的分组数不饿能超过n</li>
<li>对所有已发送但未确认的分组统一设置定时器，从最老的分组开始计时</li>
<li>超时重传分组n和窗口中所有序号大于n且已发送的分组</li>
</ul>
<h5 id="GBN滑动窗口大小"><a href="#GBN滑动窗口大小" class="headerlink" title="GBN滑动窗口大小"></a>GBN滑动窗口大小</h5><p>发送端&lt;=2^k-1</p>
<p>接收端=1</p>
<h5 id="SR协议"><a href="#SR协议" class="headerlink" title="SR协议"></a>SR协议</h5><p>接收方&lt;=2^(k-1)</p>
<h3 id="传输层协议（2）——TCP"><a href="#传输层协议（2）——TCP" class="headerlink" title="传输层协议（2）——TCP"></a>传输层协议（2）——TCP</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>面向连接：TCP连接仅存于端系统，中间路由器对此毫不知情  </p>
</li>
<li><p>全双工服务：可双向同时传输数据  </p>
</li>
<li><p>点对点连接：仅存在于两个端系统之间，无第三者“插足”  </p>
</li>
<li><p>三次握手：建立连接，协商参数  </p>
</li>
<li><p>可靠的字节流：MSS（最大报文段长）=MTU（最大传输单元）-链路层首部</p>
<p><strong>TCP报文段=数据字段（MSS限制）+TCP首部</strong></p>
</li>
</ul>
<h4 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h4><p> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1609999576689.png" alt="1609999576689"></p>
<ul>
<li><p>源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 </p>
</li>
<li><p>序号字段——占 4 字节。 TCP 连接中传送的数据流中的每一个字节都编上一个序号。 序号字段的值则指的是本报文段所发送的<strong>数据</strong>的<strong>第一个字节</strong>在整个报文字节流中的<strong>序号</strong>。  </p>
</li>
<li><p>确认号字段——占 4 字节，是<strong>期望收到</strong>对方的下一个<strong>报文段</strong>的数据的<strong>第一个字节</strong>的<strong>序号</strong>。</p>
</li>
<li><p>首部长度——占 4 bit，它指示意32bit的字为单位的TCP首部长度。 若选项字段为空， TCP首部典型长度为20字节。  </p>
</li>
<li><p>保留字段——占 6 bit，保留为今后使用，但目前应置为0。</p>
</li>
<li><p>紧急比特 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。（一般不使用）</p>
</li>
<li><p>确认比特 ACK —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。</p>
</li>
<li><p>推送比特 PSH (PuSH) —— 接收 TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。</p>
</li>
<li><p>复位比特 RST (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</p>
</li>
<li><p>同步比特 SYN —— 同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文。 </p>
</li>
<li><p>终止比特 FIN (FINal) —— 用来释放一个连接。当FIN = 1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接  </p>
</li>
<li><p>检验和 —— 占 2 字节。 检验和字段检验的范围包括首部和数据这两部分。 在计算检验和时， 要在 TCP 报文段的前面加上 <strong>12 字节的伪首部</strong>。  </p>
</li>
<li><p>紧急指针字段 —— 占 16 bit。 紧急指针指出在本报文段中的紧急数据的<strong>最后一个</strong>字节的序号。</p>
</li>
<li><p>选项字段 —— 长度可变。 TCP 只规定了一种选项， 即最大报文段长度 MSS (Maximum Segment Size)。 MSS 告诉对方 TCP： “我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。 ”  </p>
</li>
</ul>
<h4 id="TCP超时控制"><a href="#TCP超时控制" class="headerlink" title="TCP超时控制"></a>TCP超时控制</h4><h5 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h5><p>设置的超时间隔应该大于往返时延</p>
<h5 id="估算往返时延"><a href="#估算往返时延" class="headerlink" title="估算往返时延"></a>估算往返时延</h5><p>EstimatedRTT = (1- α)<em>EstimatedRTT + α</em>SampleRTT  </p>
<p>参考值α=0.125</p>
<h5 id="估算偏差"><a href="#估算偏差" class="headerlink" title="估算偏差"></a>估算偏差</h5><p>DevRTT = (1-β)<em>DevRTT +β</em>|SampleRTT-EstimatedRTT|  </p>
<p>参考值β=0.25</p>
<p>第一次计算时，DevRTT=0.5*SampleRTT  </p>
<h5 id="最终设置的超时间隔"><a href="#最终设置的超时间隔" class="headerlink" title="最终设置的超时间隔"></a>最终设置的超时间隔</h5><p>TimeoutInterval = EstimatedRTT + 4*DevRTT  </p>
<h4 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h4><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><h5 id="流量控制的目的"><a href="#流量控制的目的" class="headerlink" title="流量控制的目的"></a>流量控制的目的</h5><p>如果发送者发送数据过快，接收者来不及接受，那么就会有分组丢失，流量控制的目的就是避免发送速度过快导致的分组丢失。</p>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>接收方返回的ACK包中含有自己的接收窗口大小，利用大小来控制发送方的数据发送。</p>
<h5 id="与拥塞控制的区别"><a href="#与拥塞控制的区别" class="headerlink" title="与拥塞控制的区别"></a>与拥塞控制的区别</h5><p>拥塞控制是作用于<strong>网络</strong>的，而流量控制是作用于<strong>接收者</strong>的。</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><h5 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h5><ul>
<li>网络辅助的拥塞控制：1.路由器直接发布网络拥塞的消息2.接收方通过路由器标识通知发送方网络拥塞了。</li>
<li>端到端拥塞控制：<strong>端系统</strong>通过对网络行为的<strong>观测</strong>判断网络是否发生拥塞（<strong>TCP采用</strong>）</li>
</ul>
<h5 id="发送方如何感知拥塞"><a href="#发送方如何感知拥塞" class="headerlink" title="发送方如何感知拥塞"></a>发送方如何感知拥塞</h5><ul>
<li>超时</li>
<li>三个冗余ACK</li>
</ul>
<h5 id="TCP拥塞控制算法——Reno算法"><a href="#TCP拥塞控制算法——Reno算法" class="headerlink" title="TCP拥塞控制算法——Reno算法"></a>TCP拥塞控制算法——Reno算法</h5><ul>
<li>当拥塞窗口CongWin小于门限值Threshold时，发送方处于慢启动阶段，窗口以指数速度增大。</li>
<li>当拥塞窗口CongWin大于门限值Threshold时，发送方处于拥塞避免阶段，窗口线性增大。</li>
<li>当收到3个重复的ACK时，门限值Threshold设为拥塞窗口的1/2，而拥塞窗口CongWin设为门限值Threshold。</li>
<li>当超时事件发生时，门限值Threshold设为拥塞窗口的1/2，而拥塞窗口CongWin设为1个 MSS。  </li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>实现主机到主机的通信</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>为<strong>运输层</strong>提供支持</li>
<li>实现从源主机到目标主机成功的移动数据分组，整个路径上的每一台分组交换机上均需实现网络层。</li>
</ul>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li><strong>控制层面</strong>：在全局范畴为主机之间的通信进行选路，选路的结果反映为分组交换机上的转发</li>
<li><strong>数据层面</strong>：分组交换机上的网络层根据转发表以及分组头不信息，将分组向适当链路进行转发</li>
<li>对于<strong>面向连接</strong>的网络层服务（ATM、X.25和帧中继），提供连接建立的功能。</li>
</ul>
<h4 id="分组交换机的分类"><a href="#分组交换机的分类" class="headerlink" title="分组交换机的分类"></a>分组交换机的分类</h4><ul>
<li>根据链路层首部息进行转发的——链路层节点交换机</li>
<li>根据网络层首部信息进行转发的——路由器</li>
</ul>
<h4 id="网络层提供的服务"><a href="#网络层提供的服务" class="headerlink" title="网络层提供的服务"></a>网络层提供的服务</h4><ul>
<li>面向连接的服务——虚电路，需事先握手</li>
<li>面向无连接的服务——数据报，无需握手</li>
</ul>
<h4 id="网络层与运输层相应服务的区别"><a href="#网络层与运输层相应服务的区别" class="headerlink" title="网络层与运输层相应服务的区别"></a>网络层与运输层相应服务的区别</h4><ul>
<li>网络层是向运输层提供<strong>主机</strong>到<strong>主机</strong>的服务，而运输层是向应用层提供<strong>进程</strong>到<strong>进程</strong>的服务</li>
<li>网络层仅提供上述两种服务中的一种，不同时提供两种，而运输层则同时提供两种</li>
<li>运输层的服务在网络边缘的端系统中实现，而网络层的服务则在整个网络中实现，含路由器  </li>
</ul>
<h3 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>使收发双方之间的路径表现得如同电话线路一般</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul>
<li>从源到目的主机的路径</li>
<li>VC号，沿着该路径的每段链路的一个号码</li>
<li>沿着该路径的每台路由器中的转发表</li>
</ul>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><h3 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h3><h4 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h4><h5 id="分散式交换"><a href="#分散式交换" class="headerlink" title="分散式交换"></a>分散式交换</h5><p>按照给出的目的地址，使用输入端口的内存中存储的路由选择表，查找输出端口</p>
<h5 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h5><p>以线路速度完成输入端口的处理</p>
<h5 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h5><p>线头阻塞</p>
<h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><ul>
<li><p>经内存交换</p>
<ul>
<li>在输入端口和输出端口之间的交换是在CPU（路由处理器）的直接控制下完成的  </li>
<li>分组被拷贝到系统内存中， 然后在CPU的控制下输送到输出端口  </li>
<li>转发速度受限于内存的带宽  </li>
</ul>
</li>
<li><p>经总线交换</p>
<ul>
<li>输入端口经一根共享总线将分组直接传送到输出端口  </li>
<li>总线交换的问题: 交换速度受限于总线的带宽  </li>
<li>Cisco 1900——1Gbps；Cisco5600——32Gbps</li>
</ul>
</li>
<li><p>经互联网络交换</p>
<ul>
<li>克服总线带宽限制</li>
<li>Cisco 12000通过内联网络交换速度为若干Gb/s  </li>
</ul>
</li>
</ul>
<h4 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h4><h5 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h5><p>当交换结构将分组交付给输出端口的速率超过输出链路速率时</p>
<h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><p>FCFS（先来先服务）、WFQ（加权公平排队）、按类别轮流</p>
<h5 id="排队（缓冲区设置）"><a href="#排队（缓冲区设置）" class="headerlink" title="排队（缓冲区设置）"></a>排队（缓冲区设置）</h5><p>RFC 3439：B=RTT*R</p>
<p>理论研究：N表示TCP连接数<br>$$<br>B=\frac{RTT\times R}{\sqrt N}<br>$$</p>
<h5 id="分组丢弃策略"><a href="#分组丢弃策略" class="headerlink" title="分组丢弃策略"></a>分组丢弃策略</h5><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><h4 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1610009844111.png" alt="1610009844111"></p>
<h4 id="IPv4协议（1）——编址"><a href="#IPv4协议（1）——编址" class="headerlink" title="IPv4协议（1）——编址"></a>IPv4协议（1）——编址</h4><h5 id="ip结构"><a href="#ip结构" class="headerlink" title="ip结构"></a>ip结构</h5><p>32位=网络号+主机号</p>
<h5 id="ip分类"><a href="#ip分类" class="headerlink" title="ip分类"></a>ip分类</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1610007165052.png" alt="1610007165052"></p>
<h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>从主机号中借用一部分位数作为子网号。</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>A类默认：255.0.0.0</p>
<p>B类默认：255.255.0.0</p>
<p>C类默认：255.255.255.0</p>
<h5 id="CIDR编址格式"><a href="#CIDR编址格式" class="headerlink" title="CIDR编址格式"></a>CIDR编址格式</h5><p>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}  </p>
<p>斜线记法： 192.168.0.1/24</p>
<p>简写记法： 10.0.0.0/10 10/10  </p>
<h5 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h5><p>IP地址的host-id部分所有比特都为0时，为该net-id对应子网的网络地址；  </p>
<h5 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h5><p>IP地址的host-id部分所有比特都为1时，为该net-id对应子网的广播地址  </p>
<h5 id="主机如何获得IP地址"><a href="#主机如何获得IP地址" class="headerlink" title="主机如何获得IP地址"></a>主机如何获得IP地址</h5><p>手工配置，UNIX下在/etc/rc.config</p>
<p>DHCP：应用层协议，工作在UDP上，从服务器动态获取IP地址，同时也能获取<strong>网关地址</strong>，<strong>DNS地址</strong>，<strong>子网掩码</strong></p>
<h4 id="IPv4（2）——寻址"><a href="#IPv4（2）——寻址" class="headerlink" title="IPv4（2）——寻址"></a>IPv4（2）——寻址</h4><h5 id="两级寻址过程"><a href="#两级寻址过程" class="headerlink" title="两级寻址过程"></a>两级寻址过程</h5><ul>
<li>  检查分组目的IP地址中的网络号：若网络号不是本网络，则从路由表中找出相应的转发结点地址将其转发出去。</li>
<li>  检查子网号：当网络号是本网络时，路由器将检查子网号，向相应的子网转发此分组。  </li>
</ul>
<h4 id="IPv4（3）——转发"><a href="#IPv4（3）——转发" class="headerlink" title="IPv4（3）——转发"></a>IPv4（3）——转发</h4><ol>
<li><p>从收到的分组首部提取目的IP地址D</p>
</li>
<li><p>先用各网络的子网掩码判断是否与<strong>路由器接口</strong>直接相连的网络地址匹配，若匹配，则将分组交付该接口，否则执行第三步</p>
</li>
<li><p>对<strong>路由转发表</strong>中的每一行的子网掩码进行判断，如果网络地址匹配，则将分组传送给该行指明的下一跳路由器，否则执行第四步。</p>
</li>
<li><p>若路由表中有一个<strong>默认路由器</strong>，则将分组交给默认路由器</p>
</li>
<li><p>分组出错</p>
<p><strong>若为CIDR时，多个匹配结果选择最长前缀匹配</strong></p>
</li>
</ol>
<h4 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h4><p>跨层协议，NAT转发表</p>
<p>两类地址：本地地址，全球地址</p>
<p>三种地址转换方式</p>
<ul>
<li>静态NAT：一个本地地址对应一个全球地址  </li>
<li>动态NAT：多个本地地址对应一个全球地址</li>
<li>端口NAT：一个本地地址的端口对应到一个全球地址的端口  </li>
</ul>
<h4 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h4><p>用于主机、路由器、网关之间交换网络层信息</p>
<h5 id="ICMP报文分类"><a href="#ICMP报文分类" class="headerlink" title="ICMP报文分类"></a>ICMP报文分类</h5><p>ICMP差错报告报文，ICMP询问报文。</p>
<h5 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1610009961120.png" alt="1610009961120"></p>
<h4 id="IPv6协议"><a href="#IPv6协议" class="headerlink" title="IPv6协议"></a>IPv6协议</h4><h5 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1610010193854.png" alt="1610010193854"></p>
<h3 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h3><h4 id="几个概念："><a href="#几个概念：" class="headerlink" title="几个概念："></a>几个概念：</h4><ul>
<li>默认路由器：  一台主机“直接” 连接到的路由器 。</li>
<li>源路由器：源主机的默认路由器。</li>
<li>目的路由器：目标主机的默认路由器。</li>
</ul>
<h4 id="选路算法的目的："><a href="#选路算法的目的：" class="headerlink" title="选路算法的目的："></a>选路算法的目的：</h4><p>给定一组路由器以及连接路由器的链路，从中找到一条从源路由器到目标路由器“好的”路径。</p>
<h4 id="选路算法分类："><a href="#选路算法分类：" class="headerlink" title="选路算法分类："></a>选路算法分类：</h4><h5 id="全局选路算法"><a href="#全局选路算法" class="headerlink" title="全局选路算法"></a>全局选路算法</h5><ul>
<li>所有路由器都知道整个网络拓扑图以及链路的费用信息</li>
<li>链路状态算法</li>
</ul>
<h5 id="分散式选路算法"><a href="#分散式选路算法" class="headerlink" title="分散式选路算法"></a>分散式选路算法</h5><ul>
<li>每个路由器仅有与其相连链路的费用信息</li>
<li>通过迭代计算过程与相邻节点交换信息</li>
<li>距离向量算法</li>
</ul>
<h5 id="静态选路算法"><a href="#静态选路算法" class="headerlink" title="静态选路算法"></a>静态选路算法</h5><ul>
<li>随着时间的流逝，路由的变化非常缓慢</li>
</ul>
<h5 id="动态选路算法"><a href="#动态选路算法" class="headerlink" title="动态选路算法"></a>动态选路算法</h5><ul>
<li>路由信息可以更快地发生变化  </li>
<li>周期性的更新</li>
<li>可以响应拓扑或链路费用的变化    </li>
</ul>
<h5 id="负载敏感算法"><a href="#负载敏感算法" class="headerlink" title="负载敏感算法"></a>负载敏感算法</h5><ul>
<li>链路费用会动态地变化以反映出链路的当前状况</li>
</ul>
<h5 id="负载迟钝算法"><a href="#负载迟钝算法" class="headerlink" title="负载迟钝算法"></a>负载迟钝算法</h5><ul>
<li>链路费用不明显地反映链路的当前状况  </li>
</ul>
<h4 id="层次选路算法"><a href="#层次选路算法" class="headerlink" title="层次选路算法"></a>层次选路算法</h4><h5 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h5><p>因特网规模过大——数亿个目标网络</p>
<p>路由器无法存储每台主机的选路信息</p>
<p>路由表更新的报文广播将导致无剩余带宽供用户数据使用</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>互联网划分为多个自治系统（autonomous system,AS），每个AS内部可以和别的AS使用不同的路由选择协议，根据使用的范围差异可以将路由选择协议分为</p>
<p>自治系统内部的协议（interior gateway protocols, IGP）：RIP和OSPF</p>
<p>自治系统间的协议（border gateway protocol, BGP）</p>
<h3 id="因特网中的选路算法"><a href="#因特网中的选路算法" class="headerlink" title="因特网中的选路算法"></a>因特网中的选路算法</h3><h4 id="选路信息协议——RIP（距离向量算法）"><a href="#选路信息协议——RIP（距离向量算法）" class="headerlink" title="选路信息协议——RIP（距离向量算法）"></a>选路信息协议——RIP（距离向量算法）</h4><p>一个运行在UDP上的应用层协议，端口520</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>相同下一跳——更新</p>
<p>新的项目——添加</p>
<p>不同下一跳——距离更短才更新</p>
<h4 id="链路状态选路——OSPF协议"><a href="#链路状态选路——OSPF协议" class="headerlink" title="链路状态选路——OSPF协议"></a>链路状态选路——OSPF协议</h4><h4 id="AS间的路由——BGP4"><a href="#AS间的路由——BGP4" class="headerlink" title="AS间的路由——BGP4"></a>AS间的路由——BGP4</h4><p>半永久的TCP连接,179端口。</p>
<p>跨越两个AS的BGP连接称为外部BGP（eBGP）</p>
<p>相同AS中的两台路由器的BGP会话称为内部BGP（iBGP）</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h4 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h4><ul>
<li>成帧、链路访问<ul>
<li>将数据加上头部和尾部，封装成数据帧</li>
<li>共享介质的信道访问</li>
<li>帧头部用MAC地址标识源和目的（不同于IP地址）  </li>
</ul>
</li>
<li>可靠传递<ul>
<li>很少用于误码率低的链路（光纤、双绞线链路）</li>
<li>用于误码率高的链路（无线链路）  </li>
</ul>
</li>
<li>流量控制<ul>
<li>在相邻的收发节点间限制流量  </li>
</ul>
</li>
</ul>
<h4 id="链路层的实现"><a href="#链路层的实现" class="headerlink" title="链路层的实现"></a>链路层的实现</h4><ul>
<li>在每一台设备上（主机、交换机、路由器）</li>
<li>链路层在“适配器”（网卡NIC）或者芯片上实现</li>
<li>直接与主机的系统总线相连</li>
<li>是硬件、软件和固件的结合体  </li>
</ul>
<h4 id="检错和纠错"><a href="#检错和纠错" class="headerlink" title="检错和纠错"></a>检错和纠错</h4><h5 id="因特网检查和"><a href="#因特网检查和" class="headerlink" title="因特网检查和"></a>因特网检查和</h5><p>累加求和，计算和的反码，仅用于TCP、UDP和IPv4协议中。</p>
<h5 id="循环冗余检验码"><a href="#循环冗余检验码" class="headerlink" title="循环冗余检验码"></a>循环冗余检验码</h5><p>$$<br>R=remainder\frac{D\times 2^r}{G}<br>$$</p>
<h4 id="两种链路"><a href="#两种链路" class="headerlink" title="两种链路"></a>两种链路</h4><ul>
<li>点到点链路：PPP/以太网交换机和主机之间的点到点链路</li>
<li>广播链路（共享链路或介质）：传统以太网/HFC/802.11无线LAN</li>
</ul>
<h4 id="广播链路的碰撞"><a href="#广播链路的碰撞" class="headerlink" title="广播链路的碰撞"></a>广播链路的碰撞</h4><p>一个节点同时收到两个或多个信号。</p>
<h3 id="多址访问协议"><a href="#多址访问协议" class="headerlink" title="多址访问协议"></a>多址访问协议</h3><h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><p><strong>TDMA</strong> Time Division Multiple Access 时分多路复用  </p>
<p><strong>FDMA</strong> Frequence Division Multiple Access 码分多路复用</p>
<p><strong>CDMA</strong> Code Division Multiple Access 码分多址</p>
<h4 id="随机访问协议"><a href="#随机访问协议" class="headerlink" title="随机访问协议"></a>随机访问协议</h4><p>ALOHA、时隙ALOHA  </p>
<h5 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h5><p>载波侦听多路访问</p>
<p>以太网是一种流行并广泛部署的CSMA协议</p>
<h5 id="载波侦听"><a href="#载波侦听" class="headerlink" title="载波侦听"></a>载波侦听</h5><p>说话之前先听</p>
<h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><p>具有碰撞检测的CSMA</p>
<h5 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h5><h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><p>交换局域网解决了多址访问的带宽衰减问题</p>
<p>MAC地址：在数据链路层标识每块网络适配器，使得能够在广播信道上寻址目标节点 </p>
<p>前24bit由IEEE分配管理——OUI号，后24bit由厂商自行分配</p>
<p>地址解析协议（ARP）：  &lt; IP; MAC;TTL&gt;  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Manu Zhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Manu Zhu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统复习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-06 11:31:25 / Modified: 11:31:53" itemprop="dateCreated datePublished" datetime="2021-01-06T11:31:25+08:00">2021-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>操作系统基本功能</p>
<ul>
<li>文件管理</li>
<li>存储管理</li>
<li>设备管理</li>
<li>进程管理</li>
</ul>
<p>单道批处理系统特点</p>
<ul>
<li>一批：作业队列</li>
<li>自动：识别作业</li>
<li>单道：串行</li>
</ul>
<p>联机批处理：主机控制输入输出</p>
<p>脱机批处理：卫星机控制输入输出</p>
<p>多道批处理系统特点</p>
<ul>
<li>多道：内存同时存放多道程序</li>
<li>宏观上并行： 同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕。 </li>
<li>微观上串行： 从微观上看，内存中的多道程序轮流地或分时地占有CPU。 </li>
</ul>
<p>分时系统特点</p>
<ul>
<li>多路调制性：多用户联机使用同一台计算机</li>
<li>独占性：用户感觉独占计算机</li>
<li>交互性：及时响应用户的请求</li>
</ul>
<p>理解操作系统特性</p>
<ul>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>程序执行方式</p>
<ul>
<li><p>顺序执行</p>
<p>① 顺序性：指处理机严格地按照程序所规定的的顺序执行。</p>
<p>② 封闭性：指程序在封闭的环境下运行，即程序运行时独占全机资源（没有其它程序一起共享），资源的状态只有本机才能改变。</p>
<p>③ 可再现性 只要程序执行时的环境和初始条件相同，当程序重复执行时，都可获得相同的结果。 </p>
</li>
<li><p>并发执行</p>
<p>① 间断性：也就是一个程序的整个执行过程是“走走停停”的，由于共享资源，这些并发的程序相互制约，有时需要进行等待，造成了 “执行——暂停——执行” 的间断性活动规律。</p>
<p>② 失去封闭性：由于并发的程序之间共享系统资源，导致其中任一程序在运行时，其环境都必然会收到其它程序的影响，所以就失去了运行环境的封闭性。</p>
<p>③ 不可再现性：程序在并发执行时，由于失去了封闭性，从而也失去了不可再现性。换句话说，程序在多次执行后，虽然它们执行的环境和初始条件是相同的，但得到的结果却各不相同。</p>
</li>
</ul>
<p>虚拟机 = 裸机 + 配置操作系统</p>
<ul>
<li>用户界面：OS提供给用户控制计算机的机制，又称用户接口。（操作界面 + 系统调用）</li>
<li>屏蔽硬件细节</li>
<li>扩展硬件功能</li>
<li>系统更安全</li>
<li>系统更可靠</li>
<li>效率更高</li>
</ul>
<p>操作系统的逻辑结构</p>
<ul>
<li>单体式结构：操作系统四个功能放在一个模块里  UNIX/LINUX</li>
<li>模块化结构：windowsNT</li>
<li>可扩展化结构：微内核+核外服务器（以进程形式运行在用户态）MINIX/WINCE</li>
<li>层次式结构：  把所有功能模块按照调用次序分别排成若干层，确保各层之间只能是单向依赖或单向调用  MSDOS</li>
</ul>
<p>态：核态（目态），用户态（管态）</p>
<p>操作系统生成过程</p>
<ul>
<li>根据硬件环境/用户要求配置功能模块和构造参数</li>
<li>构建（build）OS的映像  </li>
</ul>
<p>操作系统启动过程</p>
<ul>
<li><p>初始引导：把OS内核装入内存并使之开始工作接管计算机系统</p>
<p>（FFFF0H单元的命令）加电自检 JUMP POST -》启动程序运行-》启动程序加载MBR中的引导程序-》引导程序加载硬盘上OS内核，并初始化基本参数-》OS内核边运行，边逐步加载OS的剩余部分。</p>
</li>
<li><p>核心初始化：OS内核初始化系统的核心数据（各种寄存器，存储系统的页表，核心进程）</p>
</li>
<li><p>系统初始化：为用户使用系统作准备，使系统处于待命状态（文件系统，网络系统，初始化控制台，初始化图形界面）</p>
</li>
</ul>
<p>中断定义：指CPU对突发的外部事件的反应过程或机制  </p>
<p>向量中断就是不同的中断有不同的入口地址，非向量中断就只有一个入口地址，进去了在判断中断标志来识别具体是哪个中断。向量中断实时性好，非向量中断简单 </p>
<ul>
<li>向量中断——由硬件提供中断服务程序入口地址；</li>
<li>非向量中断——由软件件提供中断服务程序入口地址； </li>
</ul>
<p>中断类型</p>
<ul>
<li><p>强迫中断和自愿中断</p>
<ul>
<li>强迫中断：程序没有预期：例：I/O、外部中断</li>
<li>自愿中断：程序有预期。例：执行访管指令</li>
</ul>
</li>
<li><p>外中断（中断）和内中断（俘获）</p>
<ul>
<li>外中断：由CPU外部事件引起。例：I/O，外部事情。</li>
<li>内中断：由CPU内部事件引起。例：访管中断、程序中断</li>
</ul>
</li>
<li><p>外中断：不可屏蔽中断和可屏蔽中断</p>
<ul>
<li>不可屏蔽中断：中断的原因很紧要，CPU必须响应</li>
<li>可屏蔽中断：中断原因不很紧要，CPU可以不响应  </li>
</ul>
</li>
</ul>
<p>中断相应过程：</p>
<ul>
<li>识别中断源</li>
<li>保护断点和现场</li>
<li>装入中断服务程序 CS:IP</li>
<li>进入中断服务程序</li>
<li>恢复现场和断点</li>
<li>中断返回：IRET  </li>
</ul>
<p>系统调用</p>
<p>特点：</p>
<ul>
<li>一般涉及核心资源或硬件的操作</li>
<li>运行于核态。</li>
<li>每个系统调用具有唯一的编号：ID</li>
<li>调用过程会产生中断：自愿中断  </li>
</ul>
<p>DOS： INT 21H（AH存放系统调用的编号）<br>LINUX：INT 80H（EAX存放系统调用的编号）</p>
<p>进程 = 程序 + 数据 + PCB</p>
<p>进程是资源分配的最小单位，线程是cpu调度的最小单位</p>
<p>进程的特征</p>
<ul>
<li>动态性 进程是程序的一次执行过程，动态产生/消亡</li>
<li>并发性 进程可以同其他进程一起向前推进；</li>
<li>异步性 进程按各自速度向前推进</li>
<li>独立性 进程是系统分配资源和调度CPU的单位；</li>
</ul>
<p>进程的状态：</p>
<ol>
<li>就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。</li>
<li>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。</li>
<li>阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</li>
</ol>
<p>状态变迁：</p>
<ul>
<li>就绪-》运行：进程调度</li>
<li>运行-》就绪：时间片到；被抢占</li>
<li>运行-》阻塞：等待某事件如I/O请求</li>
<li>阻塞-》就绪：I/O结束或等待的事情发生</li>
</ul>
<p>五态：</p>
<ul>
<li><p>活跃就绪：是指进程在主存并且可被调度的状态。</p>
</li>
<li><p>静止就绪（挂起就绪）：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。</p>
</li>
<li><p>活跃阻塞：是指进程已在主存，一旦等待的事件产生便进入活跃就绪状态。</p>
</li>
<li><p>静止阻塞：是指进程对换到辅存时的阻塞状态，一旦等待的事件产生便进入静止就绪状态。</p>
<p><img src="https://img-blog.csdn.net/20170820104628964?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWljaGVuZzc3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
</li>
</ul>
<p>进程控制块(Process Control Block，PCB)  ：包含pid，进程当前的状态，next指针（指向当前队列的下一个进程），进程优先级，cpu现场保护区，和别的进程的通信信息，家族关系，占有资源清单等等。 </p>
<p>进程控制的概念：在进程生存全期间，对其全部行为的控制</p>
<p>四个典型的控制行为</p>
<ul>
<li>创建进程</li>
<li>撤消进程</li>
<li>阻塞进程</li>
<li>唤醒进程</li>
</ul>
<p>原语：由若干指令构成的具有特定功能的函数，具有原子性，其操作不可分割</p>
<p>临界资源：一次只允许一个进程独占访问使用的资源</p>
<p>临界区：进程中访问临界资源的程序段</p>
<p>设计临界区访问机制的四个原则</p>
<ul>
<li>忙则等待</li>
<li>空闲让进</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<p>同步：  合作进程中某些操作之间需要满足某种先后关系或某个操作能否进行需要某个前提条件满足，否则只能等待  </p>
<p>同步编程应用：</p>
<ul>
<li>临界区（锁）CRITICAL_SECTION    在进程内使用，保证仅一个线程可以申请到该对象。  </li>
<li>互斥量(Mutex) （锁）HANDLE    保证只有一个线程或进程可以申请到该对象。  </li>
<li>信号量（Semaphore）HANDLE    允许指定数目的多个线程/进程访问临界区  </li>
<li>事件（Event）HANDLE    用于通知一个或多个线程某事件出现或标识某操作已经完成。  </li>
<li>等待操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WINDOWS同步机制</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD nCount,<span class="comment">//等待对象的数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">	CONST HANDLE *lpHandles,<span class="comment">//对象句柄的数组</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bWaitAll,<span class="comment">//等待方式（true全部等待）</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwMilliseconds<span class="comment">//等待时间，单位MS</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hHandle,<span class="comment">//对象句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwMilliseconds<span class="comment">//等待时间，单位MS</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">/****************************************************************/</span></span><br><span class="line">EnterCriticalSection( );<span class="comment">//上锁操作/进入临界区</span></span><br><span class="line">LeaveCriticalSection( );<span class="comment">//开锁操作/离开临界区</span></span><br><span class="line">InitializeCriticalSection( );<span class="comment">//初始化临界区/初始化锁</span></span><br><span class="line">DeleteCriticalSection( );<span class="comment">//删除临界区/删除锁</span></span><br><span class="line"><span class="comment">/****************************************************************/</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">( <span class="comment">//创建互斥量 :全局用1次</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bInitialOwner, <span class="comment">// 初始化互斥量的状态：真或假</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpName <span class="comment">// 名字，可为NULL但不能跨进程用</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenMutex</span><span class="params">(<span class="comment">//打开互斥量: 每个进程用1次</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpName <span class="comment">// 名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(<span class="comment">//关闭互斥量: 每个进程用1次</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hObject <span class="comment">// 句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ReleaseMutex</span><span class="params">(<span class="comment">// 释放：开锁</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hMutex <span class="comment">// 句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">/****************************************************************/</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">( <span class="comment">//创建信号量：全局用1次</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,<span class="comment">// 安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LONG lInitialCount, <span class="comment">// 初始值</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LONG lMaximumCount, <span class="comment">// 最大值</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpName <span class="comment">// 名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenSemaphore</span><span class="params">(<span class="comment">//打开信号量：每个进程用1次</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwDesiredAccess, <span class="comment">// 存取方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bInheritHandle, <span class="comment">// 是否能被继承</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpName <span class="comment">// 名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(<span class="comment">//关闭信号量：每个进程用1次</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hObject <span class="comment">// 句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ReleaseSemaphore</span><span class="params">(<span class="comment">//释放信号量</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hSemaphore, <span class="comment">// 句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LONG lReleaseCount, <span class="comment">// 释放数，让信号量的值增加的数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPLONG lpPreviousCount <span class="comment">// 得到释放前信号量的值，可为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">/****************************************************************/</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span> <span class="params">( <span class="comment">//创建事件对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="comment">// 安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bManualReset, <span class="comment">// 是否为人工重置</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bInitialState, <span class="comment">// 初始状态是否为有信号状态</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpName <span class="comment">// 名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">OpenEvent</span> <span class="params">(<span class="comment">//打开事件对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwDesiredAccess, <span class="comment">// 存取方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL bInheritHandle, <span class="comment">// 是否能够被继承</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpName <span class="comment">// 名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span> <span class="params">(<span class="comment">//设置事件为无信号状态</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hEvent <span class="comment">// 句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">SetEvent</span> <span class="params">(<span class="comment">//设置事件有信号状态</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hEvent <span class="comment">// 句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span> <span class="params">(<span class="comment">//关闭事件对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hObject <span class="comment">// 句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>进程通信</p>
<ul>
<li>管道通信仅能用于父子或兄弟进程间通信</li>
<li>双向通信必须建立2个管道</li>
</ul>
<p>软件中断：由写在程序中的语句引起的中断程序的执行，称为软件中断。</p>
<p>Linux软中断通信机制</p>
<ul>
<li>kill(pid, sig)：传递软中断信号</li>
<li>signal(sig, func)：注册软中断信号</li>
<li>wait( )：用于父子进程间的同步</li>
<li>sleep( n )：使当前进程睡眠n秒后自动唤醒自己 </li>
</ul>
<p>死锁：两个或多个进程无限期地等待永远不会发生的条件的一种系统状态。</p>
<p>死锁的原因：</p>
<ul>
<li>系统资源有限</li>
<li>并发进程推进顺序不当</li>
</ul>
<p>死锁的必要条件 ：</p>
<ul>
<li>资源独占性</li>
<li>不可剥夺</li>
<li>部分分配</li>
<li>环路条件</li>
</ul>
<p>预防死锁：</p>
<ul>
<li>破坏互斥条件</li>
<li>破坏不剥夺条件</li>
<li>破坏部分分配条件     预先静态分配法</li>
<li>破坏环路条件             有序资源分配法</li>
</ul>
<p>避免死锁：银行家算法</p>
<p>检测死锁</p>
<p>恢复死锁</p>
<p>进程调度概念：  在合适的时候以一定策略选择一个就绪进程运行  </p>
<p>进程调度的目标</p>
<ul>
<li>响应速度尽可能快</li>
<li>进程处理的时间尽可能短</li>
<li>系统吞吐量尽可能大</li>
<li>资源利用率尽可能高</li>
<li>对所有进程要公平</li>
<li>避免饥饿</li>
<li>避免死锁</li>
</ul>
<p>进程调度两个量化的衡量指标</p>
<ul>
<li>周转时间/平均周转时间      进程提交给计算机到完成所花费的时间  </li>
<li>带权周转时间/平均带权周转时间      进程的周转时间/进程的运行时间</li>
</ul>
<p>进程调度算法</p>
<ul>
<li>先来先服务调度（First Come First Serve）</li>
<li>短作业优先调度算法（Short Job First）</li>
<li>响应比高者优先调度算法    响应比 =（等待时间+运行时间）/运行时间  </li>
<li>优先数调度算法      进程优先数=静态优先数+动态优先数  </li>
<li>循环轮转调度法（ROUND-ROBIN）    进程以时间片q为单位轮流使用CPU</li>
<li>可变时间片轮转调度法    时间片的大小可变</li>
<li>多重时间片循环调度法    组织多个轮转队列</li>
</ul>
<p>linux进程调度</p>
<ul>
<li>基于优先级调度，选择优先级最高的进程运行</li>
<li>既支持普通的分时进程，也支持实时进程</li>
<li>让实时进程优先于普通进程</li>
<li>保证普通进程公平使用CPU时间 </li>
</ul>
<ul>
<li><p>普通进程</p>
<p>采用动态优先级来调度</p>
<p>调度程序周期性地修改优先级（避免饥饿）</p>
</li>
<li><p>实时进程</p>
<p>采用静态优先级来调度</p>
<p>由用户预先指定，以后不会改变  </p>
<p>实时进程的优先级总是比普通进程的优先级高  </p>
</li>
</ul>
<p>存储管理的功能</p>
<ul>
<li>地址映射</li>
<li>虚拟存储<ol>
<li>页式虚拟存储</li>
<li>段式虚拟存储</li>
</ol>
</li>
<li>内存分配</li>
<li>存储保护</li>
</ul>
<p>物理内存管理</p>
<ul>
<li><p>单一区存储管理（不分区存储管理）</p>
</li>
<li><p>分区存储管理</p>
<p>分区的分配  在所有空闲区中寻找一个空闲区，分配给用户使用。</p>
<ol>
<li>首次适应法   尽可能地先利用低地址空间</li>
<li>最佳适应法   选中分区是满足要求的最小的空闲区</li>
<li>最坏适应法   空闲区表按大小递减排序</li>
</ol>
</li>
<li><p>内存覆盖技术  常驻区 覆盖区</p>
</li>
<li><p>内存交换技术 </p>
<p>内存不够时把进程写到磁盘（换出/Swap Out）</p>
<p>当进程要运行时重新写回内存（换入/Swap In）</p>
</li>
</ul>
<p>虚拟内存管理</p>
<p>改善物理内存管理的相关技术</p>
<ul>
<li>内存拼接</li>
<li>对换技术【Swapping】</li>
<li>覆盖技术【Overlay】</li>
</ul>
<p>典型虚拟内存管理方式</p>
<ul>
<li><p>页式虚拟存储管理</p>
<ul>
<li><p>虚拟地址VA 分成页号P和页内偏移W</p>
</li>
<li><p>页表扩充</p>
<ul>
<li><p>中断位I ——标识该页是否在内存</p>
<p>I =１，不在内存</p>
<p>I =０，在内存</p>
</li>
<li><p>辅存地址——该页在辅存上的位置</p>
</li>
<li><p>访问位——标识该页最近是否被访问？</p>
<p>０ 最近没有被访问</p>
<p>１ 最近已被访问</p>
</li>
<li><p>修改位——标识该页的数据是否已被修改？</p>
<p>０ 该页未被修改</p>
<p>１ 该页已被修改</p>
</li>
</ul>
</li>
<li><p>缺页中断</p>
</li>
<li><p>淘汰策略</p>
<ul>
<li><p>最佳算法（OPT算法）</p>
<p>淘汰以后不再需要或最远的将来才会用到的页面</p>
</li>
<li><p>先进先出淘汰算法（FIFO算法）</p>
<p>淘汰在内存中停留时间最长的页面</p>
</li>
<li><p>最久未使用淘汰算法（LRU算法）</p>
<p>淘汰最长时间未被使用的页面，页面设置一个定时器（移位寄存器R）。页面被访问则重置1。周期性地(周期很短)将所有页面的R左移1位（右边补0）</p>
</li>
<li><p>最不经常使用（LFU算法 ）</p>
<p>选择到当前时间为止被访问次数最少的页面</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>段式虚拟存储管理</p>
</li>
<li><p>段页式虚拟存储管理</p>
</li>
</ul>
<p>设备按信息组织特征分为<strong>字符设备</strong>(如打印机), <strong>块设备</strong>(如磁盘),<strong>网络设备</strong> </p>
<p>设备独立性</p>
<ul>
<li>设备独立性：<strong>用户在程序中仅使用仅与实际设备无关的逻辑设备名</strong>。</li>
<li>逻辑设备名：用户自己指定的暂时的、可更改的设备名 (或设备号)。</li>
<li>物理设备名：系统提供的永久的、不可更改的设备标准名称。  </li>
</ul>
<ul>
<li>程序独立于分配给它的某种类型的具体设备<ol>
<li>系统可动态分配给程序某类设备中任一台物理设备，程序都<br>能正确地执行。</li>
</ol>
</li>
<li>程序应尽可能与它所使用的I/O设备类型无关<ol>
<li>在输入/输出信息时，信息可以来自不同类型的具体设备</li>
<li>若要改变输入 /输出设备的类型，程序只需进行最少的改动。</li>
</ol>
</li>
<li>设备独立性的优点<ol>
<li>方便用户</li>
<li>改善设备利用率</li>
<li>提高系统的可扩展性和可适应性修改。  </li>
</ol>
</li>
</ul>
<p>缓冲： 用来暂时存放io数据的区域。 </p>
<p>引入缓冲的原因：</p>
<ul>
<li>生产、消费者速度有差异</li>
<li>传输数据速度不一致</li>
<li>可以用来实现应用程序的拷贝</li>
</ul>
<p>缓冲作用：</p>
<ul>
<li>连接不同数据传输速度的设备</li>
<li>协调数据记录大小的不一致</li>
<li>正确执行应用程序的语义拷贝  </li>
</ul>
<p>spolling技术</p>
<ul>
<li>任务执行前：预先将程序和数据输入到输入井中</li>
<li>任务运行时：使用数据时，从输入井中取出</li>
<li>任务运行时：输出数据时，把数据写入输出井</li>
<li>任务运行完：外设空闲时输出全部数据和信息 </li>
</ul>
<p>设备驱动程序的开发过程</p>
<p>文件是系统中信息存放的一种组织形式</p>
<ul>
<li>文件是若干信息项的构成。（信息项可以是字节，可以是结构化数据。）</li>
<li>用户通过读写指针来存取文件的信息项。</li>
<li>文件具有文件名。用户通过文件名存取文件。  </li>
</ul>
<p>文件分类</p>
<ul>
<li><p>用途：系统文件，库文件，用户文件</p>
</li>
<li><p>操作权限：只读文件，读写文件，不保护文件</p>
</li>
<li><p>性质：普通文件，目录文件，设备文件</p>
</li>
<li><p>逻辑结构：流式文件（采用），记录文件</p>
</li>
<li><p>物理结构：</p>
<p>连续文件</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1609829442770.png" alt="1609829442770"></p>
<p>索引结构</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1609829571681.png" alt="1609829571681"></p>
<p>串联文件（FAT文件系统）</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1609829594656.png" alt="1609829594656"></p>
</li>
</ul>
<p>文件系统的目标是让用户以文件名来存取文件  </p>
<p>文件逻辑结构</p>
<ul>
<li> (用户的观点)</li>
<li> 为用户提供逻辑结构清晰、使用方便的文件。</li>
<li> 强调文件信息项的<strong>构成方式</strong>和用户的<strong>存取方式</strong>。  </li>
</ul>
<p>文件物理结构</p>
<ul>
<li>(系统的观点)</li>
<li>文件在存储设备（例:硬盘）上的存储结构</li>
<li>强调合理利用储存空间，缩短I/O存取时间。  </li>
</ul>
<p>记录磁盘空闲块的方法：</p>
<ul>
<li>空闲文件目录：一片连续空闲区组成一个空闲文件</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1609858113570.png" alt="1609858113570"></p>
<ul>
<li><p>空闲块链：所有空闲块连接在一起</p>
</li>
<li><p>位示图：每个bit对应1个存储块的使用情况，0表示占用，1表示空闲</p>
</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1609858143738.png" alt="1609858143738"></p>
<p>文件目录管理</p>
<p>文件目录：  文件名址录，记录文件名和存放地址的目录表  </p>
<p>文件全名：  包括从根目录开始到文件为止的通路上所有子目录路径。  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Manu Zhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Manu Zhu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
